/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/compiler/codegen.js":
/*!*********************************!*\
  !*** ./src/compiler/codegen.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"generate\": () => (/* binding */ generate)\n/* harmony export */ });\n// src/compiler/codegen.js\n\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g; //匹配花括号 {{  }} 捕获花括号里面的内容\n\nfunction gen(node) {\n  // 判断节点类型\n  // 主要包含处理文本核心\n  // 源码这块包含了复杂的处理  比如 v-once v-for v-if 自定义指令 slot等等  咱们这里只考虑普通文本和变量表达式{{}}的处理\n\n  // 如果是元素类型\n  if (node.type == 1) {\n    //   递归创建\n    return generate(node);\n  } else {\n    //   如果是文本节点\n    let text = node.text;\n    // 不存在花括号变量表达式\n    if (!defaultTagRE.test(text)) {\n      return `_v(${JSON.stringify(text)})`;\n    }\n    // 正则是全局模式 每次需要重置正则的lastIndex属性  不然会引发匹配bug\n    let lastIndex = (defaultTagRE.lastIndex = 0);\n    let tokens = [];\n    let match, index;\n\n    while ((match = defaultTagRE.exec(text))) {\n      // index代表匹配到的位置\n      index = match.index;\n      if (index > lastIndex) {\n        //   匹配到的{{位置  在tokens里面放入普通文本\n        tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n      }\n      //   放入捕获到的变量内容\n      tokens.push(`_s(${match[1].trim()})`);\n      //   匹配指针后移\n      lastIndex = index + match[0].length;\n    }\n    // 如果匹配完了花括号  text里面还有剩余的普通文本 那么继续push\n    if (lastIndex < text.length) {\n      tokens.push(JSON.stringify(text.slice(lastIndex)));\n    }\n    // _v表示创建文本\n    return `_v(${tokens.join(\"+\")})`;\n  }\n}\n\n// 处理attrs属性\nfunction genProps(attrs) {\n  let str = \"\";\n  for (let i = 0; i < attrs.length; i++) {\n    let attr = attrs[i];\n    // 对attrs属性里面的style做特殊处理\n    if (attr.name === \"style\") {\n      let obj = {};\n      attr.value.split(\";\").forEach((item) => {\n        let [key, value] = item.split(\":\");\n        obj[key] = value;\n      });\n      attr.value = obj;\n    }\n    str += `${attr.name}:${JSON.stringify(attr.value)},`;\n  }\n  return `{${str.slice(0, -1)}}`;\n}\n\n// 生成子节点 调用gen函数进行递归创建\nfunction getChildren(el) {\n  const children = el.children;\n  if (children) {\n    return `${children.map((c) => gen(c)).join(\",\")}`;\n  }\n}\n// 递归创建生成code\nfunction generate(el) {\n  let children = getChildren(el);\n  let code = `_c('${el.tag}',${\n    el.attrs.length ? `${genProps(el.attrs)}` : \"undefined\"\n  }${children ? `,${children}` : \"\"})`;\n  return code;\n}\n\n\n//# sourceURL=webpack://vue/./src/compiler/codegen.js?");

/***/ }),

/***/ "./src/compiler/index.js":
/*!*******************************!*\
  !*** ./src/compiler/index.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"compileToFunctions\": () => (/* binding */ compileToFunctions)\n/* harmony export */ });\n/* harmony import */ var _parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse */ \"./src/compiler/parse.js\");\n/* harmony import */ var _codegen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./codegen */ \"./src/compiler/codegen.js\");\n\n\nfunction compileToFunctions(template) {\n  // 我们需要把html字符串变成render函数\n  // 1.把html代码转成ast语法树  ast用来描述代码本身形成树结构 不仅可以描述html 也能描述css以及js语法\n  // 很多库都运用到了ast 比如 webpack babel eslint等等\n  let ast = (0,_parse__WEBPACK_IMPORTED_MODULE_0__.parse)(template);\n\n  // 2.优化静态节点\n  // 这个有兴趣的可以去看源码  不影响核心功能就不实现了\n  //   if (options.optimize !== false) {\n  //     optimize(ast, options);\n  //   }\n\n  // 3.通过ast 重新生成代码\n  // 我们最后生成的代码需要和render函数一样\n  // 类似_c('div',{id:\"app\"},_c('div',undefined,_v(\"hello\"+_s(name)),_c('span',undefined,_v(\"world\"))))\n  // _c代表创建元素 _v代表创建文本 _s代表文Json.stringify--把对象解析成文本\n  // _c不仅仅代表原始标签,还可以是自定义组件标签\n\n  // 生成类似于这样的  \"_c('div',{id:\"a\",style:{\"color\":\"red\"}},_v(\"hello\"+_s(a)))\"\n  let code = (0,_codegen__WEBPACK_IMPORTED_MODULE_1__.generate)(ast);\n\n  // 使用with语法改变作用域为this  之后调用render函数可以使用call改变this 方便code里面的变量取值\n  // 在template中使用 {{name}} ,会直接查找 this.name\n  let renderFn = new Function(`with(this){return ${code}}`);\n\n  // 上面代码如下\n  // let renderFn = function () {\n  //   with (this) {\n  //     return code;\n  //   }\n  // };\n  return renderFn;\n}\n\n\n//# sourceURL=webpack://vue/./src/compiler/index.js?");

/***/ }),

/***/ "./src/compiler/parse.js":
/*!*******************************!*\
  !*** ./src/compiler/parse.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"parse\": () => (/* binding */ parse)\n/* harmony export */ });\nconst ncname = `[a-zA-z_][\\\\-\\\\.0-9_a-zA-Z]*`;\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`; //匹配特殊标签 形如 abc:234 前面的abc:可有可无\nconst startTagOpen = new RegExp(`^<${qnameCapture}`); // 匹配标签开始 形如 <abc-123 捕获里面的标签名\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`); // 匹配标签结尾的\nconst attribute =\n  /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>']+)))?/; // 属性匹配\nconst startTagClose = /^\\s*(\\/?)>/; // 匹配标签结束的\n\nfunction parse(html) {\n  // 可以不停的截取模板 ， 直到把模板全部解析完毕\n  // 构建父子关系\n  let stack = [];\n  let root = null;\n  function createASTElement(tag, attrs, parent = null) {\n    return {\n      tag,\n      type: 1, // 元素\n      children: [],\n      parent,\n      attrs,\n    };\n  }\n  function start(tag, attrs) {\n    // 遇到开始标签就取栈中的最后一个作为父节点\n    let parent = stack[stack.length - 1];\n    let element = createASTElement(tag, attrs, parent);\n    if (root == null) {\n      // 说明当前节点就是根节点\n      root = element;\n    }\n    if (parent) {\n      element.parent = parent; // 更新p的parent属性，指向parent\n      parent.children.push(element);\n    }\n    stack.push(element);\n  }\n  function end(tagName) {\n    let endTag = stack.pop();\n    if (endTag.tag != tagName) {\n      console.log(\"标签出错\");\n    }\n  }\n  function text(chars) {\n    let parent = stack[stack.length - 1];\n    chars = chars.replace(/\\s/g, \"\");\n    if (chars) {\n      parent.children.push({\n        type: 2,\n        text: chars,\n      });\n    }\n  }\n  function advance(len) {\n    html = html.substring(len);\n  }\n  function parserStartTag() {\n    const start = html.match(startTagOpen);\n    if (start) {\n      const match = {\n        tagName: start[1],\n        attrs: [],\n      };\n      advance(start[0].length);\n      let end;\n      let attr;\n      while (\n        !(end = html.match(startTagClose)) &&\n        (attr = html.match(attribute))\n      ) {\n        // 1.要有属性，不能为开始的结束标签\n        match.attrs.push({\n          name: attr[1],\n          value: attr[3] || attr[4] || attr[5],\n        });\n        advance(attr[0].length);\n      }\n      if (end) {\n        advance(end[0].length);\n      }\n      return match;\n    }\n    return false;\n  }\n  while (html) {\n    // 解析标签和文本\n    let index = html.indexOf(\"<\");\n    if (index == 0) {\n      // 解析开始标签， 并且把属性也解析出来\n      const startTagMatch = parserStartTag();\n      if (startTagMatch) {\n        // 开始标签\n        start(startTagMatch.tagName, startTagMatch.attrs);\n        continue;\n      }\n      let endTagMatch;\n      if ((endTagMatch = html.match(endTag))) {\n        // 结束标签\n        end(endTagMatch[1]);\n        advance(endTagMatch[0].length);\n        continue;\n      }\n      break;\n    }\n    // 文本\n    if (index > 0) {\n      let chars = html.substring(0, index);\n      text(chars);\n      advance(chars.length);\n    }\n  }\n  return root;\n}\n\n\n//# sourceURL=webpack://vue/./src/compiler/parse.js?");

/***/ }),

/***/ "./src/global-api/assets.js":
/*!**********************************!*\
  !*** ./src/global-api/assets.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ASSETS_TYPE\": () => (/* binding */ ASSETS_TYPE),\n/* harmony export */   \"default\": () => (/* binding */ initAssetRegisters)\n/* harmony export */ });\nconst ASSETS_TYPE = [\"component\", \"directive\", \"filter\"];\n// 存在全局filter、全局directive,全局component, 最终都要放到Vue.options上的,在局部组件注册时,会合并全局的Vue.options,这样就可以在任何Vue实例(组件)中使用全局组件、全局指令、全局过滤器\nfunction initAssetRegisters(Vue) {\n  ASSETS_TYPE.forEach((type) => {\n    Vue[type] = function (id, definition) {\n      // 通过Vue.component注册的全局组件\n      if (type === \"component\") {\n        // 全局组件注册,this指向Vue\n        // this.options._base指向Vue,源码也是这样写的\n        // 用Vue.extend将传来options(definition)包装,返回一个Vue子构造函数(VueComponent)\n        definition = this.options._base.extend(definition);\n      }\n\n      // 将其添加到全局options的components对象中,后续与组件合并\n      this.options[type + \"s\"][id] = definition;\n    };\n  });\n}\n\n\n\n//# sourceURL=webpack://vue/./src/global-api/assets.js?");

/***/ }),

/***/ "./src/global-api/index.js":
/*!*********************************!*\
  !*** ./src/global-api/index.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"initGlobalApi\": () => (/* binding */ initGlobalApi)\n/* harmony export */ });\n/* harmony import */ var _initMixin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./initMixin */ \"./src/global-api/initMixin.js\");\n/* harmony import */ var _assets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assets */ \"./src/global-api/assets.js\");\n/* harmony import */ var _initExtend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./initExtend */ \"./src/global-api/initExtend.js\");\n\n\n\n\nfunction initGlobalApi(Vue) {\n  // 全局options，组件初始化时,将这个options合并到每个组件上,全局mixin、全局components、全局filter等会往上面放\n  Vue.options = {};\n\n  // options.components = {}\n  _assets__WEBPACK_IMPORTED_MODULE_1__.ASSETS_TYPE.forEach((type) => {\n    Vue.options[type + \"s\"] = {};\n  });\n\n  // 后续组件合并options时,_base也会合并到组件的$opitons上,所以在每一个组件的$opitons上都有_base属性,指向Vue！！！\n  Vue.options._base = Vue; //_base指向Vue\n\n  // 创建Vue.mixin方法\n  (0,_initMixin__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(Vue);\n\n  // 创建Vue.extend全局方法\n  (0,_initExtend__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Vue);\n\n  // 创建Vue.component、Vue.filter、Vue.directive 等全局方法\n  (0,_assets__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Vue);\n\n  // Vue.options._base = Vue;\n  // // 通过Vue.extend 方法可以产生一个子类，new子类的时候会执行代码初始化流程（组件的初始化）\n\n  // Vue.component = function (id, definition) {\n  //   // definition可以传入对象或函数\n  //   let name = definition.name || id;\n  //   definition.name = name;\n  //   if (isObject(definition)) {\n  //     definition = Vue.extend(definition);\n  //   }\n  //   Vue.options.components[name] = definition;\n  // };\n}\n\n\n//# sourceURL=webpack://vue/./src/global-api/index.js?");

/***/ }),

/***/ "./src/global-api/initExtend.js":
/*!**************************************!*\
  !*** ./src/global-api/initExtend.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ initExtend)\n/* harmony export */ });\n/* harmony import */ var _util_mergeOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/mergeOptions */ \"./src/util/mergeOptions.js\");\n\n\n// 通过调用Vue.extend(options)可以返回一个构造器,它其实就是Vue构造函数的 子构造函数,继承了Vue,与Vue构造函数作用一致\n// 继承Vue构造函数,这里为了后续便于扩展 options\n// 如 const Profile = Vue.extend({template:'xx',...}),Profile是一个构造函数,\n// new Profile({$el:'xxx', crated(){} ....}), 在Sub构造函数中拿到传入的options,然后_init时会合并options,将Vue.extend传入的options与 new 传入的options进行合并！！！\n\nfunction initExtend(Vue) {\n  let cid = 0; //组件的唯一标识\n\n  // 创建子类继承Vue父类 便于属性扩展\n  Vue.extend = function (extendOptions) {\n    // 创建子类的构造函数 并且调用初始化方法\n    const Sub = function VueComponent(options) {\n      // 这里的this指向Sub实例\n      // _init是Vue.prototype上的方法, this.__proto__ = Sub.prototype  this.__proto__.__proto__ = Vue.Prototype\n      this._init(options); //调用Vue初始化方法\n    };\n\n    Sub.cid = cid++;\n    // 这里的this指向Vue,通过Vue.extend调用的方法,this.prototype = Vue.prototype\n    Sub.prototype = Object.create(this.prototype); // 子类原型指向父类,原型继承\n    //constructor指回自己\n    Sub.prototype.constructor = Sub;\n    // this.options就是Vue.options,全局(Vue.)options和传入options合并\n    Sub.options = (0,_util_mergeOptions__WEBPACK_IMPORTED_MODULE_0__.mergeOptions)(this.options, extendOptions);\n\n    return Sub;\n  };\n}\n\n\n//# sourceURL=webpack://vue/./src/global-api/initExtend.js?");

/***/ }),

/***/ "./src/global-api/initMixin.js":
/*!*************************************!*\
  !*** ./src/global-api/initMixin.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ initMixin)\n/* harmony export */ });\n/* harmony import */ var _util_mergeOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/mergeOptions */ \"./src/util/mergeOptions.js\");\n\nfunction initMixin(Vue) {\n  Vue.mixin = function (options) {\n    // 这里的this指向Vue构造函数\n    this.options = (0,_util_mergeOptions__WEBPACK_IMPORTED_MODULE_0__.mergeOptions)(this.options, options);\n    return this;\n  };\n}\n\n\n//# sourceURL=webpack://vue/./src/global-api/initMixin.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./init.js */ \"./src/init.js\");\n/* harmony import */ var _lifecycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lifecycle */ \"./src/lifecycle.js\");\n/* harmony import */ var _render__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./render */ \"./src/render.js\");\n/* harmony import */ var _global_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./global-api */ \"./src/global-api/index.js\");\n\n\n\n\n\n// Vue就是一个构造函数 通过new关键字进行实例化\nfunction Vue(options) {\n  // 这里开始进行Vue初始化工作\n  this._init(options);\n}\n// _init方法是挂载在Vue原型的方法 通过引入文件的方式进行原型挂载需要传入Vue\n// 此做法有利于代码分割\n(0,_init_js__WEBPACK_IMPORTED_MODULE_0__.initMixin)(Vue);\n\n// 混入_render\n(0,_render__WEBPACK_IMPORTED_MODULE_2__.renderMixin)(Vue);\n\n// 混入_update\n(0,_lifecycle__WEBPACK_IMPORTED_MODULE_1__.lifecycleMixin)(Vue);\n\n// 挂载全局API， 如Vue.extend Vue.use Vue.mixin\n(0,_global_api__WEBPACK_IMPORTED_MODULE_3__.initGlobalApi)(Vue);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Vue);\n\n// demo使用\nVue.mixin({\n  created() {\n    // console.log(\"mixin created\");\n  },\n  components: {\n    log() {\n      return \"mixin\";\n    },\n  },\n});\n\nVue.component(\"component1\", {\n  data() {\n    return {\n      count: 1,\n    };\n  },\n  template: `<div>我是compoent1，我的count是{{count}}</div>`,\n});\n\n// const Ctor = Vue.extend({\n//   data() {\n//     return {\n//       count: 1,\n//     };\n//   },\n//   template: \"<div>我是compoent1,count:{{count}}</div>\",\n//   components: {\n//     log() {\n//       return \"extend\";\n//     },\n//   },\n// });\n\n// // 实例化\n// new Ctor({\n//   created() {\n//     console.log(\"new extend返回值 传入的参数\");\n//   },\n//   components: {\n//     log() {\n//       return \"new Ctor\";\n//     },\n//   },\n// });\n\n// Vue实例化\n\nconst component2 = {\n  template: `<h3 style=\"color:orange\">component2</h3>`,\n  beforeCreate() {\n    console.log(\"子组件beforeCreate\");\n  },\n  created() {\n    console.log(\"子组件的created\");\n  },\n  beforeMount() {\n    console.log(\"子组件的beforeMount\");\n  },\n  mounted() {\n    // 这里$el可以拿到渲染后的dom\n    console.log(\"子组件的mounted\");\n  },\n};\n\nconst vm = new Vue({\n  el: \"#app\",\n  data() {\n    return {\n      a: 111,\n      b: [1, 2, 34],\n    };\n  },\n  template: `<div id=\"aaa\" style=\"color:red\">hello{{a}} <div> {{b}}</div> <component1></component1>  <component2></component2></div>`,\n  components: {\n    component2,\n  },\n\n  watch: {\n    a(o, n) {\n      console.log(\"watchaaaaaaaaaa\", o, n);\n    },\n  },\n\n  beforeCreate() {\n    console.log(\"父组件beforeCreate\");\n  },\n  created() {\n    console.log(\"父组件的created\");\n  },\n  beforeMount() {\n    console.log(\"父组件的beforeMount\");\n  },\n  mounted() {\n    // 这里$el可以拿到渲染后的dom\n    console.log(\"父组件的mounted\");\n  },\n});\n\n// 我们在这里模拟更新\nsetTimeout(() => {\n  // 批量异步更新机制\n  vm.a = 456;\n  vm.a = 999;\n  vm.b.push(111);\n\n  // 当data更新了,这里手动去update,更新dom\n  // 这里不会再执行init => compiler了,更新了data,后面在_render中调用 render函数时将虚拟dom转为真实dom,可以拿到新的data\n  // 这里只新dom替换老dom,不触发compiler,触发render+patch\n  // vm._update(vm._render());\n}, 1000);\n\n\n//# sourceURL=webpack://vue/./src/index.js?");

/***/ }),

/***/ "./src/init.js":
/*!*********************!*\
  !*** ./src/init.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"initMixin\": () => (/* binding */ initMixin)\n/* harmony export */ });\n/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./state */ \"./src/state.js\");\n/* harmony import */ var _compiler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compiler */ \"./src/compiler/index.js\");\n/* harmony import */ var _lifecycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lifecycle */ \"./src/lifecycle.js\");\n/* harmony import */ var _util_mergeOptions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/mergeOptions */ \"./src/util/mergeOptions.js\");\n/* harmony import */ var _util_callHook__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util/callHook */ \"./src/util/callHook.js\");\n/* harmony import */ var _observer_watcher__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./observer/watcher */ \"./src/observer/watcher.js\");\n// src/init.js\n\n\n\n\n\n\n\nfunction initMixin(Vue) {\n  Vue.prototype._init = function (options) {\n    const vm = this;\n    // 这里的this代表调用_init方法的对象(实例对象)\n    //  this.$options就是用户new Vue的时候传入的属性\n\n    // 这里要和全局的option进行合并,存在全局的minxin！！！\n    // vm.constructor = vm.__proto__.constructor = Vue\n    // 这里的this不仅仅是Vue实例,也可能是Sub实例,Sub是Vue.extend()的返回值\n    // 故这里vm.constructor.options 可能是 Vue.options 或 Sub.options\n    vm.$options = (0,_util_mergeOptions__WEBPACK_IMPORTED_MODULE_3__.mergeOptions)(vm.constructor.options, options);\n\n    // 调用生命周期hook,状态初始化之前,数据观测、事件配置之前\n    (0,_util_callHook__WEBPACK_IMPORTED_MODULE_4__.callHook)(vm, \"beforeCreate\");\n\n    // 初始化状态\n    (0,_state__WEBPACK_IMPORTED_MODULE_0__.initState)(vm);\n\n    // 状态初始化完毕,data属性已经观测完毕\n    (0,_util_callHook__WEBPACK_IMPORTED_MODULE_4__.callHook)(vm, \"created\");\n\n    // 如果有el属性 进行模板渲染,页面渲染只会调一次$mount，后续不再模版渲染\n    // 如果是组件的话,是没有el的,组件会调用$mount\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n\n  // 这块代码在源码里面的位置其实是放在entry-runtime-with-compiler.js里面\n  // 代表的是Vue源码里面包含了compile编译功能 这个和runtime-only版本需要区分开\n  Vue.prototype.$mount = function (el) {\n    const vm = this;\n    const options = vm.$options;\n    // 获取DOM\n    el = document.querySelector(el);\n    // 如果不存在render属性\n    if (!options.render) {\n      // 如果存在template属性\n      let template = options.template;\n\n      if (!template && el) {\n        // 如果不存在render和template 但是存在el属性 直接将el自身作为template\n        // el.outerHTML获取自身的html字符串\n        template = el.outerHTML;\n      }\n\n      // 最终需要把tempalte模板转化成render函数\n      if (template) {\n        // 拿到形如这样的一个函数\n        // (function anonymous(\n        //   ) {\n        //   with(this){return _c('div',{id:\"a\",style:{\"color\":\"red\"}},_v(\"hello\"+_s(a)))}\n        //   })\n        // compiler阶段！！！将html字符串转为render函数\n        const render = (0,_compiler__WEBPACK_IMPORTED_MODULE_1__.compileToFunctions)(template);\n        options.render = render;\n      }\n    }\n\n    // 将当前组件实例挂载到真实的el节点上面\n    return (0,_lifecycle__WEBPACK_IMPORTED_MODULE_2__.mountComponent)(vm, el);\n  };\n\n  // 挂载侦听属性API\n  Vue.prototype.$watch = function (exprOrFn, cb, options) {\n    debugger\n\n    const vm = this;\n    //  user: true 这里表示是一个用户watcher\n    new _observer_watcher__WEBPACK_IMPORTED_MODULE_5__[\"default\"](vm, exprOrFn, cb, { ...options, user: true });\n\n    // 如果有immediate属性 代表需要立即执行回调,上来先执行一次\n    if (options.immediate) {\n      cb();\n    }\n  };\n}\n\n\n//# sourceURL=webpack://vue/./src/init.js?");

/***/ }),

/***/ "./src/lifecycle.js":
/*!**************************!*\
  !*** ./src/lifecycle.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"lifecycleMixin\": () => (/* binding */ lifecycleMixin),\n/* harmony export */   \"mountComponent\": () => (/* binding */ mountComponent)\n/* harmony export */ });\n/* harmony import */ var _vdom_patch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vdom/patch */ \"./src/vdom/patch.js\");\n/* harmony import */ var _observer_watcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./observer/watcher */ \"./src/observer/watcher.js\");\n/* harmony import */ var _util_callHook__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/callHook */ \"./src/util/callHook.js\");\n\n\n\n\nfunction mountComponent(vm, el) {\n  // 上一步模板编译解析生成了render函数\n  // 下一步就是执行vm._render()方法 调用生成的render函数 生成虚拟dom\n\n  // 真实的el选项赋值给实例的$el属性 为之后虚拟dom产生的新的dom替换老的dom做铺垫\n  vm.$el = el;\n\n  // el挂载开始之前调用,这里还以拿到$el，不过还是一个html字符串模版,还没有render\n  (0,_util_callHook__WEBPACK_IMPORTED_MODULE_2__.callHook)(vm, \"beforeMount\");\n\n  // 调用_render函数, 在其内部会调用之前生成的render函数,然后生成虚拟dom,dom的描述对象\n  // _update在首次渲染和DOM更新时都会被调用，虚拟DOM转为真实DOM，新DOM替换老DOM\n  // vm._update(vm._render());\n  // 引入watcher的概念 这里注册一个渲染watcher 执行vm._update(vm._render())方法渲染视图\n\n  let updateComponent = () => {\n    // render+patch\n    // 整个Watcher都会更新,一个组件对应一个Watcher\n    vm._update(vm._render());\n  };\n\n  // $mount中注册了Watcher\n  // mount阶段会实例化Wathcer,一个组件对应一个Wathcer\n  // Watcher首次会调用_update方法,完成render更新\n  new _observer_watcher__WEBPACK_IMPORTED_MODULE_1__[\"default\"](vm, updateComponent, null, true);\n\n  // _update执行完毕,将虚拟dom生成真实dom替换el,页面已经显示了\n  (0,_util_callHook__WEBPACK_IMPORTED_MODULE_2__.callHook)(vm, \"mounted\");\n}\n\n// 注意：这里都是以单个组件来讲的,一个组件只有一个Wathcer,也只会产生一个render函数,组件更新时,重新执行render函数生成虚拟dom,然后再_update再patch\n// 故_preVnode 保存着当前组件上一次的虚拟节点！！！ 组件维度！！！\nfunction lifecycleMixin(Vue) {\n  // 把_update挂载在Vue的原型\n  Vue.prototype._update = function (vnode) {\n    const vm = this;\n    let preVnode = vm._preVnode;\n    // 将当前虚拟节点放到vm上\n    vm._preVnode = vnode;\n\n    // 首次渲染_preVnode为空,这时需要生成DOM替换el,dom更新时,_preVode有值,需要执行属性比对差异更新、diff算法\n    // 第一次渲染是根据虚拟节点，生成真实节点，替换原来的节点\n    if (!preVnode) {\n      vm.$el = (0,_vdom_patch__WEBPACK_IMPORTED_MODULE_0__.patch)(vm.$el, vnode);\n    } else {\n      // 第二次，生成一个新的虚拟节点，和老的虚拟节点进行对比\n      // 将更新后的真实dom赋值给$el\n      vm.$el = (0,_vdom_patch__WEBPACK_IMPORTED_MODULE_0__.patch)(preVnode, vnode);\n    }\n  };\n}\n\n// $vnode 和_vnode区别\n// $vnode代表组件标签占位符的虚拟节点，  _vnode是组件template中html的虚拟节点\n// _vnode.parent = $vnode\n\n\n//# sourceURL=webpack://vue/./src/lifecycle.js?");

/***/ }),

/***/ "./src/observer/arrary.js":
/*!********************************!*\
  !*** ./src/observer/arrary.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"arrayMethods\": () => (/* binding */ arrayMethods)\n/* harmony export */ });\n// 先保留数组原型\nconst arrayProto = Array.prototype;\n// 然后将arrayMethods继承自数组原型\n// 这里是面向切片编程思想（AOP）--不破坏封装的前提下，动态的扩展功能\n\nconst arrayMethods = Object.create(arrayProto);\n\nlet methodsToPatch = [\n  \"push\",\n  \"pop\",\n  \"shift\",\n  \"unshift\",\n  \"splice\",\n  \"reverse\",\n  \"sort\",\n];\n\nmethodsToPatch.forEach((method) => {\n  // 往arrayMethods上追加方法,对象的原型是Arrary.prototype\n  // 重写数组方法仅仅为了能劫持数组操作,能感知数组的值更新了，然后可以派发更新。 数组实例如果调用的不是重写方法,则会往__proto__.__proto__上找，就是Arrary.prototype，原型链知识\n  arrayMethods[method] = function (...args) {\n    // 还是调用原有的方法,Arrary.prototype上的\n    const result = arrayProto[method].apply(this, args);\n    // 这句话是关键\n    // 通过this.xx.methods,故这里的this就是数据本身\n    //  比如数据是{a:[1,2,3]} 那么我们使用a.push(4)  this就是a  ob就是a.__ob__  代表的是该数据已经被响应式观察过了指向Observer实例\n    const ob = this.__ob__;\n\n    // 这里的标志就是代表数组有新增操作\n    let inserted;\n    switch (method) {\n      case \"push\":\n      case \"unshift\":\n        inserted = args;\n        break;\n      case \"splice\":\n        inserted = args.slice(2); // x.splice(0,1,2) 这里获取splice可能新增的元素\n    }\n\n    // 如果有新增的元素 inserted是一个数组 调用Observer实例的observeArray对数组新增的每一项进行观测\n    // 如果新增的是对象,则属性劫持,如果新增的是数组则重写方法,如果简单数据类型忽略\n    if (inserted) ob.observeArray(inserted); // 对新增的每一项进行观测\n    // 派发更新    \n    ob.dep.notify(); //数组派发更新 ob指的就是数组对应的Observer实例 我们在get的时候判断如果属性的值还是对象那么就在Observer实例的dep收集依赖 所以这里是一一对应的  可以直接更新\n    return result;\n  };\n});\n\n\n//# sourceURL=webpack://vue/./src/observer/arrary.js?");

/***/ }),

/***/ "./src/observer/dep.js":
/*!*****************************!*\
  !*** ./src/observer/dep.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Dep),\n/* harmony export */   \"popTarget\": () => (/* binding */ popTarget),\n/* harmony export */   \"pushTarget\": () => (/* binding */ pushTarget)\n/* harmony export */ });\n// src/observer/dep.js\n\n// dep和watcher是多对多的关系\n// 每个属性都有自己的dep\nlet id = 0; //dep实例的唯一标识\nclass Dep {\n  constructor() {\n    this.id = id++;\n    this.subs = []; // 这个是存放watcher的容器\n  }\n  depend() {\n    // 如果当前存在watcher\n    if (Dep.target) {\n      // Dep.target 是Watcher实例,给Watcher推入当前dep,收集依赖\n      // Watcher中addDep会判断dep是否重复,不重复才会收集这个dep,同时dep也会收集这个watcher,这是一个同时的关系,若这个dep在wathcer中重复，那么这个watcher在dep中也是重复的！！！故只需要在Watcher中去重。\n      Dep.target.addDep(this); // 把自身-dep实例存放在watcher里面\n    }\n  }\n  notify() {\n    //   依次执行subs里面的watcher更新方法\n    // 目前来看只有一个Watcher???\n    this.subs.forEach((watcher) => watcher.update());\n  }\n\n  addSub(watcher) {\n    //   把watcher加入到自身的subs容器\n    this.subs.push(watcher);\n  }\n}\n// 默认Dep.target为null\nDep.target = null;\n\n// 栈结构用来存watcher\nconst targetStack = [];\n\n// 可能存在多个Watcher,一个组件一个渲染watcher,多个用户自定义watcher,故通过栈结构来维护\nfunction pushTarget(watcher) {\n  targetStack.push(watcher);\n  Dep.target = watcher; // Dep.target指向当前watcher\n}\nfunction popTarget() {\n  targetStack.pop(); // 当前watcher出栈 拿到上一个watcher\n  Dep.target = targetStack[targetStack.length - 1];\n}\n\n\n//# sourceURL=webpack://vue/./src/observer/dep.js?");

/***/ }),

/***/ "./src/observer/index.js":
/*!*******************************!*\
  !*** ./src/observer/index.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"observe\": () => (/* binding */ observe)\n/* harmony export */ });\n/* harmony import */ var _arrary__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrary */ \"./src/observer/arrary.js\");\n/* harmony import */ var _dep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dep */ \"./src/observer/dep.js\");\n\n\n\nclass Observer {\n  // 观测值\n  constructor(value) {\n    // 不仅给对象属性上添加dep,对象自身也需要添加dep，这里主要是给数组添加dep的！即{a:[1,2,3]},后续在defineReactive中发现value是数组会递归创建Observe的\n    this.dep = new _dep__WEBPACK_IMPORTED_MODULE_1__[\"default\"](); // 给对象和数组都增加dep属性\n\n    // 为复杂数据类型添加 `__ob__`属性,其值是当前Observer实例,代表已被响应式处理\n    Object.defineProperty(value, \"__ob__\", {\n      //  值指代的就是Observer的实例\n      value: this,\n      //  不可枚举\n      enumerable: false,\n      writable: true,\n      configurable: true,\n    });\n\n    if (Array.isArray(value)) {\n      // 这里对数组做了额外判断\n      // 通过重写数组原型方法来对数组的七种方法进行拦截\n      value.__proto__ = _arrary__WEBPACK_IMPORTED_MODULE_0__.arrayMethods;\n      // 对数组的每一项进行递归,存在数组项为对象、数组的情况,为对象的话走属性劫持\n      this.observeArray(value);\n    } else {\n      this.walk(value);\n    }\n  }\n\n  walk(data) {\n    // 对象上的所有属性依次进行观测\n    for (let key in data) {\n      defineReactive(data, key, data[key]);\n    }\n  }\n\n  // 递归观测数组，重写数组方法\n  observeArray(items) {\n    for (let i = 0; i < items.length; i++) {\n      observe(items[i]);\n    }\n  }\n}\n\n// Object.defineProperty数据劫持核心\nfunction defineReactive(data, key, value) {\n  // 递归\n  let childOb = observe(value); // childOb就是Observer实例\n\n  // 每一个属性都有一个Dep实例\n  let dep = new _dep__WEBPACK_IMPORTED_MODULE_1__[\"default\"](); // 为每个属性实例化一个Dep\n\n  // --如果value还是一个对象会继续走一遍odefineReactive 层层遍历一直到value不是对象才停止\n  //   思考？如果Vue数据嵌套层级过深 >>性能会受影响\n\n  // 这里只是先观测着,劫持对象属性观测,后续render中的访问data属性时,getter触发时收集依赖\n  Object.defineProperty(data, key, {\n    // 真正触发getter是在_render，_render中执行用户传入的render函数或我们转化的render函数,这时会访问data属性,触发依赖收集\n    get() {\n      // 页面取值的时候 可以把watcher收集到dep里面--依赖收集\n      // 只有Dep.target有值时才会收集依赖,在$mount时才会注册Watcher,Watcher首次时会将Dep.target赋值\n      if (_dep__WEBPACK_IMPORTED_MODULE_1__[\"default\"].target) {\n        // 如果有watcher dep就会保存watcher 同时watcher也会保存dep\n        dep.depend();\n\n        // 如果是简单数据类型，childOb会是undefined\n        if (childOb) {\n          // 这里表示 属性的值依然是一个对象 包含数组和对象 childOb指代的就是Observer实例对象  里面的dep进行依赖收集\n          // 比如{a:[1,2,3]} 属性a对应的值是一个数组 观测数组的返回值就是对应数组的Observer实例对象\n          childOb.dep.depend(); // 数组收集依赖,每个数组都有个dep 收集watcher,当调用重写方法时,执行notify\n          // 如果数据结构类似 {a:[1,2,[3,4,[5,6]]]} 这种数组多层嵌套  数组包含数组的情况  那么我们访问a的时候 只是对第一层的数组进行了依赖收集 里面的数组因为没访问到  所以五大收集依赖  但是如果我们改变了a里面的第二层数组的值  是需要更新页面的  所以需要对数组递归进行依赖收集\n          if (Array.isArray(value)) {\n            // 如果内部还是数组\n            dependArray(value); // 不停的进行依赖收集\n          }\n        }\n      }\n      return value;\n    },\n\n    set(newValue) {\n      if (newValue === value) return;\n      // 如果赋值的新值也是一个对象  需要观测\n      observe(newValue);\n      value = newValue;\n\n      // 一个组件一个Wathcer\n      dep.notify(); // 通知渲染watcher去更新--派发更新\n    },\n  });\n}\n\nfunction observe(value) {\n  // 如果传过来的是对象或者数组 进行属性劫持\n  // 简单数据类型直接忽略,不需要劫持\n  // 每个引用数据都有一个Oberserve实例\n  if (\n    Object.prototype.toString.call(value) === \"[object Object]\" ||\n    Array.isArray(value)\n  ) {\n    return new Observer(value);\n  }\n}\n\n// 递归收集数组依赖\n// 形如的[[123],[23]]的递归收集依赖\nfunction dependArray(value) {\n  let e;\n  for (let i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    // e.__ob__代表e已经被响应式观测了 但是没有收集依赖 所以把他们收集到自己的Observer实例的dep里面\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      // 如果数组里面还有数组  就递归去收集依赖\n      dependArray(e);\n    }\n  }\n}\n\nObject.defineProperties(obj, \"arr\", {\n  get(value) {\n    console.log(\"依赖收集\");\n    return value;\n  },\n});\n\n\n\n//# sourceURL=webpack://vue/./src/observer/index.js?");

/***/ }),

/***/ "./src/observer/scheduler.js":
/*!***********************************!*\
  !*** ./src/observer/scheduler.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"queueWatcher\": () => (/* binding */ queueWatcher)\n/* harmony export */ });\n/* harmony import */ var _util_next_tick__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/next-tick */ \"./src/util/next-tick.js\");\n// src/observer/scheduler.js\n// 新建 scheduler.js 文件 表示和调度相关 先同步把 watcher 都放到队列里面去 执行完队列的事件之后再清空队列 主要使用 nextTick 来执行 watcher 队列\n\n\n// 全局变量\nlet queue = [];\nlet has = {}; // 缓存表\n\nfunction flushSchedulerQueue() {\n  for (let index = 0; index < queue.length; index++) {\n    //   调用watcher的run方法 执行真正的更新操作\n    queue[index].run();\n  }\n  // 执行完之后清空队列\n  queue = [];\n  has = {};\n}\n\n// 实现异步队列机制\n// schedule中有个异步任务队列,当频繁更新同一data时，这个属性会派发多次更新,同一watcher会重复render,故这里缓存,只需要一个watcher进行更新即可,批量更新机制\n// 推入队列后，然后执行nextTick异步方法\nfunction queueWatcher(watcher) {\n  const id = watcher.id;\n  //   watcher去重\n  if (has[id] === undefined) {\n    //  同步代码执行 把全部的watcher都放到队列里面去\n    queue.push(watcher);\n    has[id] = true;\n    // 进行异步调用\n    // 传入一个回调函数\n    (0,_util_next_tick__WEBPACK_IMPORTED_MODULE_0__.nextTick)(flushSchedulerQueue);\n  }\n}\n\n\n//# sourceURL=webpack://vue/./src/observer/scheduler.js?");

/***/ }),

/***/ "./src/observer/watcher.js":
/*!*********************************!*\
  !*** ./src/observer/watcher.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Watcher)\n/* harmony export */ });\n/* harmony import */ var _util_callHook__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/callHook */ \"./src/util/callHook.js\");\n/* harmony import */ var _dep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dep */ \"./src/observer/dep.js\");\n/* harmony import */ var _scheduler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scheduler */ \"./src/observer/scheduler.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util */ \"./src/util/index.js\");\n// src/observer/watcher.js\n\n\n\n\n\n\n// 全局变量id  每次new Watcher都会自增\nlet id = 0;\n\nclass Watcher {\n  /**\n   * @param {*} vm\n   * @param {*} exprOrFn 表达式 or 函数, 渲染Watcher这个参数一定是函数, 自定义watcher可能是函数，可能是表达式\n   * @param {*} cb 回调函数\n   * @param {*} options\n   * @memberof Watcher\n   */\n  constructor(vm, exprOrFn, cb, options) {\n    this.vm = vm;\n    this.exprOrFn = exprOrFn; // _update更新方法,重新render\n    this.cb = cb; //回调函数 比如在watcher更新之前可以执行beforeUpdate方法\n    this.options = options; //额外的选项 true代表渲染watcher\n    this.id = id++; // watcher的唯一标识\n    this.deps = []; //存放dep的容器\n    this.depsId = new Set(); //用来去重dep\n\n\n    //标识是用户自定义watcher\n    this.user = options.user;\n\n    // 如果表达式是一个函数\n    if (typeof exprOrFn === \"function\") {\n      this.getter = exprOrFn;\n    } else {\n      // 用户自定义watcher\n      this.getter = function () {\n        //用户watcher传过来的可能是一个字符串   类似a.a.a.a.b\n        let path = exprOrFn.split(\".\");\n        let obj = vm;\n        // 通过循环访问拿到表达式对应最终对应的属性值\n        // 这里访问了data属性，会触发getter,会将当前watcher进行收集\n        for (let i = 0; i < path.length; i++) {\n          obj = obj[path[i]]; //vm.a.a.a.a.b\n        }\n        return obj;\n      };\n    }\n\n    // 实例化就会默认调用get方法,依赖收集\n    this.value = this.get();\n  }\n\n  get() {\n    (0,_dep__WEBPACK_IMPORTED_MODULE_1__.pushTarget)(this); // 在调用方法之前先把当前watcher实例推到全局Dep.target上,方便收集依赖\n    const res = this.getter(); //如果watcher是渲染watcher 那么就相当于执行  vm._update(vm._render()) 这个方法在render函数执行的时候会取值 从而触发getter 依赖收集\n    (0,_dep__WEBPACK_IMPORTED_MODULE_1__.popTarget)(); // 在调用方法之后把当前watcher实例从全局Dep.target移除\n\n    // 用户定义的wathcer需要返回值,组件的渲染Watcher不需要返回值\n    return res;\n  }\n\n  //   把dep放到deps里面 同时保证同一个dep只被保存到watcher一次  同样的  同一个watcher也只会保存在dep一次\n  addDep(dep) {\n    let id = dep.id;\n    if (!this.depsId.has(id)) {\n      // 为了避免dep重复\n      this.depsId.add(id);\n\n      this.deps.push(dep);\n      // 直接调用dep的addSub方法  把自己--watcher实例添加到dep的subs容器里面\n      dep.addSub(this);\n    }\n  }\n\n  update() {\n    // 每次watcher进行更新的时候  是否可以让他们先缓存起来  之后再一起调用\n    // 异步队列机制,同一watcher只会推入一次,根据watcher.id来区别\n    (0,_scheduler__WEBPACK_IMPORTED_MODULE_2__.queueWatcher)(this);\n  }\n  run() {\n    // 数据更新之前调用,_update之前调用\n    (0,_util_callHook__WEBPACK_IMPORTED_MODULE_0__.callHook)(this.vm, \"beforeUpdate\");\n\n    const newVal = this.get(); //新值\n    const oldVal = this.value; //老值\n    this.value = newVal; //现在的新值将成为下一次变化的老值\n\n    // 如果是用户自定义wathcer\n    if (this.user) {\n      // 如果两次的值不相同  或者值是引用类型 因为引用类型新老值是相等的 他们是指向同一引用地址\n      if (newVal !== oldVal || (0,_util__WEBPACK_IMPORTED_MODULE_3__.isObject)(newVal)) {\n        // 执行watch的回调函数\n        this.cb.call(this.vm, newVal, oldVal);\n      }\n    } else {\n      // 渲染watcher\n      this.cb.call(this.vm);\n    }\n\n    // _update执行完毕,_render、pathch都执行完毕,虚拟dom已经替换为真实dom了\n    (0,_util_callHook__WEBPACK_IMPORTED_MODULE_0__.callHook)(this.vm, \"updated\");\n  }\n}\n\n\n//# sourceURL=webpack://vue/./src/observer/watcher.js?");

/***/ }),

/***/ "./src/render.js":
/*!***********************!*\
  !*** ./src/render.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"renderMixin\": () => (/* binding */ renderMixin)\n/* harmony export */ });\n/* harmony import */ var _vdom_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vdom/index */ \"./src/vdom/index.js\");\n/* harmony import */ var _util_next_tick__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/next-tick */ \"./src/util/next-tick.js\");\n// src/render.js\n\n\n\n\nfunction renderMixin(Vue) {\n  Vue.prototype._render = function () {\n    const vm = this;\n    // 获取模板编译生成的render方法\n    const { render } = vm.$options;\n    // 生成vnode--虚拟dom\n    // render内部执行  _c('div',{id:\"a\",style:{\"color\":\"red\"}},_v(\"hello\"+_s(a)))\n    // 所以一个template必须要有一个根元素,若有多个根元素,则这里的render函数的内部是这样的 return _c(tag,...)_c(tag,...)，这样通过ast转出来的render函数是不合法的,执行会报错\n    // render函数的的内部会访问data,触发getter,收集依赖\n    const vnode = render.call(vm);\n\n    return vnode;\n  };\n\n  // render函数里面有_c _v _s方法需要定义\n  Vue.prototype._c = function (...args) {\n    // 创建虚拟dom元素\n    return (0,_vdom_index__WEBPACK_IMPORTED_MODULE_0__.createElement)(this, ...args);\n  };\n\n  // 文本\n  Vue.prototype._v = function (text) {\n    // 创建虚拟dom文本\n    return (0,_vdom_index__WEBPACK_IMPORTED_MODULE_0__.createTextNode)(this, text);\n  };\n\n  // 双括号插值\n  Vue.prototype._s = function (val) {\n    // 如果模板里面的是一个对象  需要JSON.stringify\n    // 在template中是这样的 {{a}} 而a是一个对象\n    // 是在这里获取 data的,虽然在template时,写在一个html字符串中,其实访问这个属性是在js中完成的,html只起渲染作用,类似于模版引擎\n    // 这里会收集依赖\n    return val == null\n      ? \"\"\n      : typeof val === \"object\"\n      ? JSON.stringify(val)\n      : val; // 使用了with,这里等同于this.val,实例的this\n  };\n\n  // 挂载在原型的nextTick方法 可供用户手动调用\n  Vue.prototype.$nextTick = _util_next_tick__WEBPACK_IMPORTED_MODULE_1__.nextTick;\n}\n\n\n//# sourceURL=webpack://vue/./src/render.js?");

/***/ }),

/***/ "./src/state.js":
/*!**********************!*\
  !*** ./src/state.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"initState\": () => (/* binding */ initState)\n/* harmony export */ });\n/* harmony import */ var _observer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./observer */ \"./src/observer/index.js\");\n\n\n// 初始化状态 注意这里的顺序 比如我经常面试会问到 是否能在data里面直接使用prop的值 为什么？\n// 这里初始化的顺序依次是 prop>methods>data>computed>watch\nfunction initState(vm) {\n  // 获取传入的数据对象\n  const opts = vm.$options;\n  if (opts.props) {\n    // initProps(vm);\n  }\n  if (opts.methods) {\n    // initMethod(vm);\n  }\n  if (opts.data) {\n    // 初始化data\n    initData(vm);\n  }\n  if (opts.computed) {\n    // initComputed(vm);\n  }\n  // 侦听属性\n  if (opts.watch) {\n    initWatch(vm);\n  }\n}\n\n// 初始化data数据\nfunction initData(vm) {\n  let data = vm.$options.data;\n  //   实例的_data属性就是传入的data\n  // vue组件data推荐使用函数 防止数据在组件之间共享\n  data = vm._data = typeof data === \"function\" ? data.call(vm) : data || {};\n\n  // 把data数据代理到vm 也就是Vue实例上面 我们可以使用this.a来访问this._data.a\n  for (let key in data) {\n    proxy(vm, `_data`, key);\n  }\n  // 对数据进行观测 --响应式数据核心\n  (0,_observer__WEBPACK_IMPORTED_MODULE_0__.observe)(data);\n}\n\n// 数据代理\n// 将data代理到this上,通过this.xx访问this._data.xx\nfunction proxy(object, sourceKey, key) {\n  Object.defineProperty(object, key, {\n    get() {\n      return object[sourceKey][key];\n    },\n    set(newValue) {\n      object[sourceKey][key] = newValue;\n    },\n  });\n}\n\n// 初始化watch\nfunction initWatch(vm) {\n  let watch = vm.$options.watch;\n  // 为每个watch 实例化Watcher\n  for (let k in watch) {\n    const handler = watch[k]; //用户自定义watch的写法可能是数组 对象 函数 字符串\n    if (Array.isArray(handler)) {\n      // 如果是数组就遍历进行创建\n      handler.forEach((handle) => {\n        createWatcher(vm, k, handle);\n      });\n    } else {\n      createWatcher(vm, k, handler);\n    }\n  }\n}\n// 创建watcher的核心\n// exprOrFn: 表达式 or funciotn\nfunction createWatcher(vm, exprOrFn, handler, options = {}) {\n  if (typeof handler === \"object\") {\n    options = handler; //保存用户传入的对象\n    handler = handler.handler; //这个代表真正用户传入的函数\n  }\n  if (typeof handler === \"string\") {\n    //   代表传入的是定义好的methods方法\n    handler = vm[handler];\n  }\n\n  //   调用vm.$watch创建用户watcher\n  return vm.$watch(exprOrFn, handler, options);\n}\n\n\n//# sourceURL=webpack://vue/./src/state.js?");

/***/ }),

/***/ "./src/util/callHook.js":
/*!******************************!*\
  !*** ./src/util/callHook.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"callHook\": () => (/* binding */ callHook)\n/* harmony export */ });\n// 生命周期钩子调用\n// hook会被包装在mergeOptions中会被包装为数组\nfunction callHook(vm, hook) {\n  // 依次执行生命周期对应的方法\n  const handlers = vm.$options[hook];\n  if (handlers) {\n    for (let i = 0; i < handlers.length; i++) {\n      handlers[i].call(vm); //生命周期里面的this指向当前实例\n    }\n  }\n}\n\n\n//# sourceURL=webpack://vue/./src/util/callHook.js?");

/***/ }),

/***/ "./src/util/index.js":
/*!***************************!*\
  !*** ./src/util/index.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isObject\": () => (/* binding */ isObject),\n/* harmony export */   \"isReservedTag\": () => (/* binding */ isReservedTag)\n/* harmony export */ });\n// src/util/index.js\n\nfunction isObject(data) {\n  //判断是否是对象\n  if (typeof data !== \"object\" || data == null) {\n    return false;\n  }\n  return true;\n}\n\n//判断是不是常规html标签\nfunction isReservedTag(tagName) {\n  let str =\n    \"html,body,base,head,link,meta,style,title,\" +\n    \"address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,\" +\n    \"div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,\" +\n    \"a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,\" +\n    \"s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,\" +\n    \"embed,object,param,source,canvas,script,noscript,del,ins,\" +\n    \"caption,col,colgroup,table,thead,tbody,td,th,tr,\" +\n    \"button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,\" +\n    \"output,progress,select,textarea,\" +\n    \"details,dialog,menu,menuitem,summary,\" +\n    \"content,element,shadow,template,blockquote,iframe,tfoot\";\n\n  // 建立一个映射表\n  let obj = {};\n  str.split(\",\").forEach((tag) => {\n    obj[tag] = true;\n  });\n\n  return obj[tagName];\n}\n\n\n//# sourceURL=webpack://vue/./src/util/index.js?");

/***/ }),

/***/ "./src/util/mergeOptions.js":
/*!**********************************!*\
  !*** ./src/util/mergeOptions.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LIFECYCLE_HOOKS\": () => (/* binding */ LIFECYCLE_HOOKS),\n/* harmony export */   \"mergeOptions\": () => (/* binding */ mergeOptions)\n/* harmony export */ });\n// 定义生命周期\nconst LIFECYCLE_HOOKS = [\n  \"beforeCreate\",\n  \"created\",\n  \"beforeMount\",\n  \"mounted\",\n  \"beforeUpdate\",\n  \"updated\",\n  \"beforeDestroy\",\n  \"destroyed\",\n];\n\n// 合并策略\nconst strats = {};\n\n//生命周期合并策略\n// 将生命周期合并为数组,mixin的在前\nfunction mergeHook(parentVal, childVal) {\n  // 如果有儿子\n  if (childVal) {\n    if (parentVal) {\n      // 合并成一个数组\n      return parentVal.concat(childVal);\n    } else {\n      // 包装成一个数组\n      // 只有儿子\n      return [childVal];\n    }\n  } else {\n    // 这个已经是数组了,第一次进来包装成Arrary了\n    return parentVal;\n  }\n}\n\n// 为生命周期添加合并策略\nLIFECYCLE_HOOKS.forEach((hook) => {\n  strats[hook] = mergeHook;\n});\n\n// 为组件添加合并策略,与其他的合并策略不同！！！\n// 组件的合并策略是通过原型来继承,即局部组件定义log方法,全局组件也有log方法,此时Vue.options.components 是 局部组件.components的对象原型(__proto__),，先查找自身的,自身查找不到查找继承的,\n// 故methods同名,优先使用自身的\n// 这里parentVal 和 childVal都是 components对象\nstrats.components = function (parentVal, childVal) {\n  let res = Object.create(parentVal || {});\n\n  if (childVal) {\n    // 合并后产生新对象，不用原来的\n    for (let key in childVal) {\n      res[key] = childVal[key];\n    }\n  }\n  return res;\n};\n\n// mixin核心方法\n// 这里合并并不是全部的,对于data的合并,可能需要合并data函数的返回值,比较麻烦,深合并,属性冲突时优先用自身的\n// 这里的parent可能是Vue.options 或 Sub.options\nfunction mergeOptions(parent, child) {\n  const options = {};\n  // 遍历父亲\n  for (let k in parent) {\n    mergeFiled(k);\n  }\n  // 父亲没有 儿子有\n  for (let k in child) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (!parent.hasOwnProperty(k)) {\n      mergeFiled(k);\n    }\n  }\n\n  function mergeFiled(k) {\n    if (strats[k]) {\n      // 特有合并策略,生命周期、组件\n      options[k] = strats[k](parent[k], child[k]);\n    } else {\n      // 默认策略\n      // 优先取当前组件的\n      options[k] = child[k] ? child[k] : parent[k];\n    }\n  }\n  return options;\n}\n\n\n//# sourceURL=webpack://vue/./src/util/mergeOptions.js?");

/***/ }),

/***/ "./src/util/next-tick.js":
/*!*******************************!*\
  !*** ./src/util/next-tick.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"nextTick\": () => (/* binding */ nextTick)\n/* harmony export */ });\n// src/util/next-tick.js\n\nlet callbacks = [];\nlet pending = false;\n\nfunction flushCallbacks() {\n  pending = false; //把标志还原为false\n  // 依次执行回调\n  for (let i = 0; i < callbacks.length; i++) {\n    callbacks[i]();\n  }\n}\n\n// 定义一个异步方法,该方法内的回调异步执行(微任务),包装为微任务优先\nlet timerFunc; //定义异步方法  采用优雅降级\n\n// 逐步降级的过程\nif (typeof Promise !== \"undefined\") {\n  // 如果支持promise\n  const p = Promise.resolve();\n  // 将flushCallbacks作为微任务\n  timerFunc = () => {\n    p.then(flushCallbacks);\n  };\n} else if (typeof MutationObserver !== \"undefined\") {\n  // 微任务\n  // MutationObserver 主要是监听dom变化 也是一个异步方法\n  let counter = 1;\n  // 观察者,节点发生变化后 会执行这个回调flushCallbacks\n  const observer = new MutationObserver(flushCallbacks);\n  // 创建一个文本节点\n  const textNode = document.createTextNode(String(counter));\n  // 观察这个文本节点内容是否发生变化\n  observer.observe(textNode, {\n    characterData: true,\n  });\n\n  // 执行timerFunc时,让文本节点发生了变化,会执行创建实例时的回调,这个回调是一个异步任务\n  timerFunc = () => {\n    counter = (counter + 1) % 2;\n    textNode.data = String(counter);\n  };\n} else if (typeof setImmediate !== \"undefined\") {\n  // 如果前面都不支持 判断setImmediate \n  // node中的宏任务\n  timerFunc = () => {\n    setImmediate(flushCallbacks);\n  };\n} else {\n  // 最后降级采用setTimeout\n  timerFunc = () => {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n\n// 调用多次nextTick只会执行一次,等任务队列(callback)清空后才会执行本次的任务队列,一段时间内清空任务队列\n// nextTick使用 promise、MutationOberserve、setImediate、setTimeout将回调包装为一个异步任务，promise和Oberserve是微任务,后面就是EventLoop的知识了\n// nextTick也有执行顺序的,比如我们操作data更新,data更新是同步的,而重新render是异步，也是通过nextTick实现，我们可以通过nextTick拿到更新后的dom,此时nextTick在执行render回调,这时pending为true,等render执行完毕,才执行我们的回调\nfunction nextTick(cb) {\n  // 除了渲染watcher  还有用户自己手动调用的nextTick 一起被收集到数组\n  callbacks.push(cb);\n\n  // 首次执行立即触发\n  if (!pending) {\n    // 如果多次调用nextTick  只会执行一次异步 等异步队列清空之后再把标志变为false\n    pending = true;\n    timerFunc();\n  }\n}\n\n\n//# sourceURL=webpack://vue/./src/util/next-tick.js?");

/***/ }),

/***/ "./src/vdom/index.js":
/*!***************************!*\
  !*** ./src/vdom/index.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createElement\": () => (/* binding */ createElement),\n/* harmony export */   \"createTextNode\": () => (/* binding */ createTextNode),\n/* harmony export */   \"default\": () => (/* binding */ Vnode)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./src/util/index.js\");\n\n\n// 定义Vnode类\n// 生成虚拟DOM\nclass Vnode {\n  // 生成一个 {tag:xx,data:xx,key:xx}这样的对象,是对DOM的描述\n  constructor(tag, data, key, children, text, options) {\n    this.tag = tag;\n    this.data = data;\n    this.key = key;\n    this.children = children;\n    this.text = text;\n    this.componentOptions = options; // 组件特有属性,存放组件构造函数、组件标签中的内容(插槽内容)\n  }\n}\n\n// 创建元素vnode 等于render函数里面的 h=>h(App)\n// 将参数转为虚拟DOM,虚拟DOM就是对DOM元素的一个描述对象\n// 自定义组件也可以作为createElment的参数,此时tag就不是一个html标签了\nfunction createElement(vm, tag, data = {}, ...children) { // 剩余参数作为children数组,作为子VNode\n  let key = data.key;\n\n  if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isReservedTag)(tag)) {\n    // 如果是普通标签\n    return new Vnode(tag, data, key, children);\n  } else {\n    // 否则就是组件\n    // 这个Cotr有可能是对象,有可能是构造函数,使用Vue.component注册的全局组件,其内部会调用Vue.extend(),返回一个VueComponent构造函数\n    // 通过Vue构造函数创建的组件,options中的components可能有对象,也需要Vue.exntend包装,任何组件都需要Vue.extend包装为构造函数\n    let Ctor = vm.$options.components[tag];\n    return createComponent(vm, tag, data, key, children, Ctor);\n  }\n}\n\n// 创建文本vnode\nfunction createTextNode(vm, text) {\n  return new Vnode(undefined, undefined, undefined, undefined, text);\n}\n\n// 创建组件VNode\nfunction createComponent(vm, tag, data, key, children, Ctor) {\n  if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(Ctor)) {\n    //   如果没有被改造成构造函数\n    Ctor = vm.$options._base.extend(Ctor);\n  }\n\n  // 给组件VNode添加回调\n  data.hook = {\n    // 执行$mount,组件初始化渲染\n    init(vnode) {\n      let child = (vnode.componentInstance = new Ctor({ _isComponent: true })); //实例化组件\n      child.$mount(); // 组件不会传入el属性, 需要手动挂载,为了将组件的VNode转为真实DOM渲染到页面上\n    },\n  };\n\n  return new Vnode(\n    `vue-component-${Ctor.cid}-${tag}`, // 组件名,不重复即可\n    data,\n    key,\n    undefined,\n    undefined,  // 组件VNode是没有children的,写在组件标签中间的内容是插槽内容,不能将其添加在VNode的children属性上,避免在patch时被创建为文本节点\n    {\n      Ctor,\n      children, // 要将children添加至VNode.componentOpitons中\n    }\n  );\n}\n\n\n//# sourceURL=webpack://vue/./src/vdom/index.js?");

/***/ }),

/***/ "./src/vdom/patch.js":
/*!***************************!*\
  !*** ./src/vdom/patch.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"patch\": () => (/* binding */ patch)\n/* harmony export */ });\n// src/vdom/patch.js\n\n// patch用来渲染和更新视图,初次渲染时,oldVnode是el指向的DOM元素，是一个真实DOM, 更新时,opldVnode是一个虚拟节点,旧的虚拟节点\n// 返回真实dom\nfunction patch(oldVnode, vnode) {\n  if (!oldVnode) {\n    // 组件的挂载流程,组件初次渲染时是没有el属性的,未在options里传\n    return createElm(vnode); // 直接生成组件的真实DOM\n  }\n\n  // 判断传入的oldVnode是否是一个真实元素\n  // 这里很关键  初次渲染 传入的vm.$el就是咱们传入的el选项  所以是真实dom\n  // 如果不是初始渲染而是视图更新的时候  vm.$el就被替换成了更新之前的老的虚拟dom\n\n  // dom中元素、空格、注释、文本等都是节点,元素的nodeType为1\n  const isRealElement = oldVnode.nodeType;\n  // oldVnode是真实dom元素 就代表初次渲染\n  if (isRealElement) {\n    const el = createElm(vnode); // 根据虚拟节点创造了真实节点\n    const parentNode = oldVnode.parentNode;\n    parentNode.insertBefore(el, oldVnode.nextSibling);\n    parentNode.removeChild(oldVnode);\n    return el;\n  } else {\n    // oldVnode是虚拟dom 就是更新过程 使用diff算法\n    if (oldVnode.tag !== vnode.tag) {\n      // 如果新旧标签不一致 直接用新的替换旧的 oldVnode.el代表的是真实dom节点--同级比较\n      oldVnode.el.parentNode.replaceChild(createElm(vnode), oldVnode.el);\n    }\n\n    // 如果旧节点是一个文本节点\n    if (!oldVnode.tag) {\n      if (oldVnode.text !== vnode.text) {\n        oldVnode.el.textContent = vnode.text;\n      }\n    }\n\n    // 不符合上面两种 代表标签一致 并且不是文本节点\n    // 为了节点复用 所以直接把旧的虚拟dom对应的真实dom赋值给新的虚拟dom的el属性\n    const el = (vnode.el = oldVnode.el);\n    updateProperties(vnode, oldVnode.data); // 更新属性,差异化更新\n    const oldCh = oldVnode.children || []; // 老的儿子\n    const newCh = vnode.children || []; // 新的儿子\n    if (oldCh.length > 0 && newCh.length > 0) {\n      // 新老都存在子节点\n      updateChildren(el, oldCh, newCh);\n    } else if (oldCh.length) {\n      // 老的有儿子新的没有\n      el.innerHTML = \"\";\n    } else if (newCh.length) {\n      // 只有新的有儿子,直接在旧dom上插入新的子dom\n      for (let i = 0; i < newCh.length; i++) {\n        const child = newCh[i];\n        el.appendChild(createElm(child));\n      }\n    }\n    return el;\n  }\n}\n\n// 判断是否是组件Vnode,内部会实例化组件,编译渲染组件内容\n// 子组件实例化、编译渲染,相当于又走了一遍 new Vue({})递归的过程,这样就递归渲染子组件,一层层嵌套递归\nfunction createComponent(vnode) {\n  // 初始化组件\n  // 创建组件实例\n  let i = vnode.data;\n  //   下面这句话很关键 调用组件data.hook.init方法进行组件初始化过程($mount)，最终组件的vnode.componentInstance.$el就是组件渲染好的真实dom\n  if ((i = i.hook) && (i = i.init)) { // 这里是安全写法\n    // 实例化组件(_init),手动执行组件$mount方法,compiler、update、patch操作\n    i(vnode);\n  }\n\n  // 如果组件实例化完毕有componentInstance属性 那证明是组件\n  if (vnode.componentInstance) {\n    return true;\n  }\n}\n\n// 虚拟dom转成真实dom 就是调用原生方法生成dom树\n// 根据tag创建dom,遍历它的属性,将其添加到dom上\nfunction createElm(vnode) {\n  let { tag, data, key, children, text } = vnode;\n  // 判断虚拟dom 是元素节点还是文本节点\n  // 文本节点是没有tag的,为undefined\n  if (typeof tag === \"string\") {\n    // 虚拟dom的el属性指向真实dom\n\n    // 有可能这个vnode是组件虚拟节点,它的tag并不是html标签\n    if (createComponent(vnode)) {\n      // 如果是组件 返回真实组件渲染的真实dom\n      // 子组件渲染完毕,会将真实DOM挂载到$el属性上,故这里直接返回子组件的真实dom即可\n      return vnode.componentInstance.$el;\n    }\n\n    // 根据标签创建真实DOM\n    vnode.el = document.createElement(tag);\n    // 解析虚拟dom属性\n    updateProperties(vnode);\n    // 如果有子节点就递归插入到父节点里面\n    children.forEach((child) => {\n      return vnode.el.appendChild(createElm(child));\n    });\n  } else {\n    //   文本节点\n    vnode.el = document.createTextNode(text);\n  }\n  return vnode.el;\n}\n\n// 解析vnode的data属性 映射到真实dom上\n// 新的有,老的没有,从dom中删除老的,追加新的\n// 老的有,新的没有，删除老的\nfunction updateProperties(vnode, oldProps = {}) {\n  // for (let key in props) {\n  //   el.setAttribute(key, props[key])\n  // }\n  // 这里的逻辑可能是初次渲染，初次渲染直接用oldProps 给vnode的el复制即可\n  // 更新逻辑拿到老的props和vnode里面的data进行比对\n  let el = vnode.el;\n  let newProps = vnode.data || {};\n\n  let newStyle = newProps.style || {};\n  let oldStyle = oldProps.style || {};\n\n  for (let key in oldStyle) {\n    // 老的样式有，新的没有，就把页面上的样式删除掉\n    if (!newStyle[key]) {\n      el.style[key] = \"\";\n    }\n  }\n  // 新旧比对，两个对象如何比对差异\n  for (let key in newProps) {\n    if (key == \"style\") {\n      for (let key in newStyle) {\n        el.style[key] = newStyle[key];\n      }\n    } else {\n      el.setAttribute(key, newProps[key]);\n    }\n  }\n  for (let key in oldProps) {\n    if (!newProps[key]) {\n      el.removeAttribute(key);\n    }\n  }\n}\n\n/** diff */\n// 判断两个vnode的标签和key是否相同 如果相同 就可以认为是同一节点就地复用\nfunction isSameVnode(oldVnode, newVnode) {\n  return oldVnode.tag === newVnode.tag && oldVnode.key === newVnode.key;\n}\n// diff算法核心 采用双指针的方式 对比新老vnode的儿子节点\n/**\n * @param {*} parent\n * @param {*} oldCh []\n * @param {*} newCh []\n */\nfunction updateChildren(parent, oldCh, newCh) {\n  let oldStartIndex = 0; //老儿子的起始下标\n  let oldStartVnode = oldCh[0]; //老儿子的第一个节点\n  let oldEndIndex = oldCh.length - 1; //老儿子的结束下标\n  let oldEndVnode = oldCh[oldEndIndex]; //老儿子的起结束节点\n\n  let newStartIndex = 0; //同上  新儿子的\n  let newStartVnode = newCh[0];\n  let newEndIndex = newCh.length - 1;\n  let newEndVnode = newCh[newEndIndex];\n\n  // 根据key来创建老的儿子的index映射表  类似 {'a':0,'b':1} 代表key为'a'的节点在第一个位置 key为'b'的节点在第二个位置\n  function makeIndexByKey(children) {\n    let map = {};\n    children.forEach((item, index) => {\n      map[item.key] = index;\n    });\n    return map;\n  }\n  // 生成的映射表\n  let map = makeIndexByKey(oldCh);\n\n  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {\n    // 暴力比对时,复用key相同的节点,将节点移到了前面去，然后将原位置置为空，这里要跳过\n    if (!oldStartVnode) {\n      oldStartVnode = oldCh[++oldStartIndex];\n    } else if (!oldEndVnode) {\n      // 同上\n      oldEndVnode = oldCh[--oldEndIndex];\n    } else if (isSameVnode(oldStartVnode, newStartVnode)) {\n      // 从头比对\n      // key是否相同\n      // 头和头对比 指针后移\n      patch(oldStartVnode, newStartVnode); //递归比较儿子以及他们的子节点,文本节点是它们的子节点\n      oldStartVnode = oldCh[++oldStartIndex];\n      newStartVnode = newCh[++newStartIndex];\n    } else if (isSameVnode(oldEndVnode, newEndVnode)) {\n      // 从尾比对\n      //尾和尾对比 依次向前追加\n      patch(oldEndVnode, newEndVnode);\n      oldEndVnode = oldCh[--oldEndIndex];\n      newEndVnode = newCh[--newEndIndex];\n    } else if (isSameVnode(oldStartVnode, newEndVnode)) {\n      // 头尾比对\n      // 老的头和新的尾相同 把老的头部移动到尾部\n      patch(oldStartVnode, newEndVnode);\n      parent.insertBefore(oldStartVnode.el, oldEndVnode.el.nextSibling); //insertBefore可以移动或者插入真实dom\n      oldStartVnode = oldCh[++oldStartIndex];\n      newEndVnode = newCh[--newEndIndex];\n    } else if (isSameVnode(oldEndVnode, newStartVnode)) {\n      // 尾头比对\n      // 老的尾和新的头相同 把老的尾部移动到头部\n      patch(oldEndVnode, newStartVnode);\n      parent.insertBefore(oldEndVnode.el, oldStartVnode.el);\n      oldEndVnode = oldCh[--oldEndIndex];\n      newStartVnode = newCh[++newStartIndex];\n    } else {\n      // 上述四种情况都不满足 那么需要暴力对比\n      // 根据老的子节点的key和index的映射表 从新的开始子节点进行查找 如果可以找到就进行移动操作 如果找不到则直接进行插入\n      let moveIndex = map[newStartVnode.key];\n      if (!moveIndex) {\n        // 老的节点找不到  直接插入\n        parent.insertBefore(createElm(newStartVnode), oldStartVnode.el);\n      } else {\n        let moveVnode = oldCh[moveIndex]; //找得到就拿到老的节点\n        oldCh[moveIndex] = undefined; // 这个老节点复用移到了前面去了，将这个位置置为空,避免后续指针移动时重复比对，这里不能删除,删除会影响索引指针\n        parent.insertBefore(moveVnode.el, oldStartVnode.el); //把找到的节点移动到最前面\n        patch(moveVnode, newStartVnode);\n      }\n    }\n  }\n\n  // 如果老节点循环完毕了 但是新节点还有  证明  新节点需要被添加到头部或者尾部\n  if (newStartIndex <= newEndIndex) {\n    for (let i = newStartIndex; i <= newEndIndex; i++) {\n      // 这是一个优化写法 insertBefore的第二个参数是null等同于appendChild作用\n      const ele =\n        newCh[newEndIndex + 1] == null ? null : newCh[newEndIndex + 1].el;\n      parent.insertBefore(createElm(newCh[i]), ele);\n    }\n  }\n  // 如果新节点循环完毕 老节点还有  证明老的节点需要直接被删除\n  if (oldStartIndex <= oldEndIndex) {\n    for (let i = oldStartIndex; i <= oldEndIndex; i++) {\n      let child = oldCh[i];\n      if (child != undefined) {\n        parent.removeChild(child.el);\n      }\n    }\n  }\n}\n\n\n//# sourceURL=webpack://vue/./src/vdom/patch.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;